<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[2017 年终总结]]></title>
      <url>/2018/01/01/2017%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="2017-总结"><a href="#2017-总结" class="headerlink" title="2017 总结"></a>2017 总结</h1><p>人生如梭，回顾过去，展望未来吧。</p>
<p>这儿是沿用一下李笑来老师的七年就是一辈子的说法，将 2017 年定为这辈子的开始，花一辈子 7 年的时间去做一件事情。</p>
<p>2016 年 12 月 我选择了前端开发为下一个开始，2017 年 1 月开始就已经彻底的投入到了这里面来，1 月 至 2 月的埋头苦学换来了 3 月第一份前端开发的工作，3000 元一个月，我很满足。</p>
<p>暗自里给自己定了一个计划，我用工资来衡量个人的技术水平。从 3000 元的工资水平到 2017 年末需要达到 5000 元的工资水平，2018 年达到 8000 元水平。按照这个计划来看，今年是失败了的，老板只开了 4000 元工资，技术水平个人评估也没有达到 5000 元的水准。</p>
<p>一方面是因为两家公司都不是很匹配我的技能。一家公司做全案策划，我只是使用开源的 CMS 系统写写网站，做做页面，业务量也不是很多。第二家公司，也就是现在还在的这家公司，做得是外包业务，我在里面属于打杂的角色，有页面我就写写页面，其他时间都是在测试、需求以及一些杂事。另一方面是因为没有一个好的交流环境，闭门学习，也没有多少机会把学习的东西实践出来，学习了过段时间没用又忘记了，没有多少成长。再一个方面就是没能彻底改掉拖延、贪玩的毛病，回到住处就没法认真学习，还好礼拜天我还知道去图书馆学习，没有放弃自己。</p>
<p>下面是一些我学到的内容</p>
<h2 id="学习的内容"><a href="#学习的内容" class="headerlink" title="学习的内容"></a>学习的内容</h2><p>学习到的东西很多，主要分为两个部分：编程知识和心理学知识，还有一些没法总结的东西。无论是能总结，还是没法总结的都在为以后打下坚实的基础。</p>
<h3 id="编程知识"><a href="#编程知识" class="headerlink" title="编程知识"></a>编程知识</h3><p>主要学习了 HTML 、CSS 、JS 三个主要吧。</p>
<p>HTML 最简单，主要记住一些标签和语义化的内容基本就够用了。CSS 比较麻烦一点，因为要兼容老版本的浏览器，所以那些特性能用，那些不能用需要知道一些。不过现在兼容性需求会比较轻松一点。JS 学了点皮毛，不精，写的代码自己也没法看，正在努力。</p>
<p>前端框架主要会 VUE ，写单页面多页面都没有问题。得益于 vue-cli 还学习了一点 webpack ，暂时还不能写 webpack 插件，还得深入学习。weex 很看好，能写点简单的 app 来玩。小程序也不错，会简单写点。</p>
<p>JQUERY 和 UI 框架不是很难，多使用多熟悉就能上手。现在回很少用 JQUERY 吧，vue 太好玩了，现在的技术中心都偏向于这种框架了。</p>
<p>还有一些小的没法总结的知识，慢慢积累吧，总会用得着。</p>
<h3 id="心理学"><a href="#心理学" class="headerlink" title="心理学"></a>心理学</h3><p>因为想要探索自己的思考方式，主要是想看能不能改善一下自己的思考方式。于是去关注了一些心理咨询老师的公众号，碎片时间学习一下，在一些老师的推荐下，看了一本《人类简史》，9月份开始看的，看了很久才拖拖拉拉的看完，现在正在看《梦的解析》。</p>
<p>对于心理学还没有完整的知识体系，但是对自己的思考方式有很大的影响。我开始思考自己的思考，在对一件事发生看法后或在对一件事做了反应后我会事后探究大脑里面我之前是如何看这些问题的是如何对这些事件进行反应的，我的这些反应的来源是哪儿，是哪些东西影响我对这件事的反应和看法。</p>
<p>反思自己是很有意思的事情，它会让自己认识自己，优点、缺点、善良的灵魂和丑恶的灵魂都会被自己审视出来，那种感觉太妙了，妙不可言。</p>
<h2 id="得到和失去"><a href="#得到和失去" class="headerlink" title="得到和失去"></a>得到和失去</h2><p>认识了一些朋友。我性子淡薄，不喜欢社交。能认识几个朋友，实乃三生之幸，感谢他们的陪伴。</p>
<p>还有就是对父母的陪伴没有达到内心的预期吧，2018 年争取多陪伴他们一下。</p>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>先说说计划吧。</p>
<p>2017年自己做了一个小程序，关于成长的。后台没有做，只能单机玩。今年想把几个小程序都做了，把后台做了，在整合起来成为一个 app 。这样就算是完成了一个产品线，给自己增加实践经验，不至于在杂务中技术得不到增长。如果在 2018 年能有一些好的想法，也会实现下来。</p>
<p>另外一个想法就是希望能够说服老板提升公司的技术水平吧，对公司也好我自己也好，能够在技术上有更好的积累。</p>
<p>再有就是达到2018年的工资预期和技术水平预期。</p>
<p>嗯，加油吧</p>
]]></content>
      
        <categories>
            
            <category> 个人 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTP URL]]></title>
      <url>/2018/01/01/HTTP%20URL/</url>
      <content type="html"><![CDATA[<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>URI（统一资源标识符）由URL（统一资源定位符）和URN（统一资源名）两个子集构成:</p>
<ul>
<li>URL 通过描述资源的位置来标识资源的，当资源位置发生改变，我们就会找不到它。</li>
<li>URN 通过名字来标识资源的，与资源所在位置没有关系。</li>
</ul>
<h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a><a href="https://github.com/woai30231/http/tree/master/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20URL%E4%B8%8E%E8%B5%84%E6%BA%90" target="_blank" rel="noopener">语法格式</a></h2><p>URL的语法描述的是URL由哪些组件构成，以及这些组件是怎么组合成一个URL，中间由什么符号连接，每个组件代表什么等！其格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>scheme:方法描述了请求资源时用了什么协议，用“:”与url其它部分隔开；</li>
<li>user:用户名描述了访问是带的用户名；</li>
<li>password:密码描述了用户名后面可能跟的密码，用“:”跟用户名隔开；</li>
<li>host:主机描述了网站主机名或ip地址，如果前面有用户名和密码，用@分开；</li>
<li>post:服务器当前正在监听的端口，http默认为80，https默认为443;</li>
<li>path:路劲描述了资源在服务器上的位置，用‘/’跟前面部分隔开；</li>
<li>params:参数描述了请求需要附加的参数，用“;”与其他部分隔开；</li>
<li>query:查询是用来激活服务器程序去执行某些操作，比如查询数据库等，用“?”与其余部分隔开；</li>
<li>frag:片段只在客户端使用，不发送到服务器端；</li>
</ul>
<h2 id="URL-编码"><a href="#URL-编码" class="headerlink" title="URL 编码"></a>URL 编码</h2><p>为了避开安全字符集表示法带来的限制，人们设计了一种编码机制，用来在 URL 中表示不安全字符。这种编码机制是通过“转义”表示法来表示不安全字符的，这种“转义”包含一个 % 号后面跟着两个表示字符的 ASCII 码的十六进制数。</p>
<p>在 URL 中，有几个字符被保留起来，有着特殊的含义。</p>
<ul>
<li>\% : 保留作为编码字符的转义标志</li>
<li>\/ : 保留作为路径组件中分隔路径段的定界符</li>
<li># : 保留作为分段定界符使用</li>
<li>\? : 保留作为查询字符串定界符使用</li>
<li>\; : 保留作为参数定界符使用</li>
<li>\: : 保留作为 scheme ，用户名和密码，主机和端口号的定界符使用</li>
<li>\$ + : 保留</li>
<li>\@ \&amp; \= : 某些方案中的上下文有特殊含义，保留</li>
<li>{ } | \^ ~ [ ] \’ : 由于网关的不安全处理，使用受限</li>
<li>\&lt; > \” : 不安全，这些字符通常在 URL 范围外是有意义的。</li>
<li>. .. : 保留在路径组件中使用</li>
<li>0x00~0x1F,0x7F : 受限，不在可打印区域。</li>
<li>>0x7F : 受限，不在 US-ASCII 字符集的 7 二进制范围内。</li>
</ul>
<h2 id="scheme"><a href="#scheme" class="headerlink" title="scheme"></a>scheme</h2><p>常见 scheme 的格式：</p>
<ul>
<li>http : 超文本传输协议，端口默认为 80</li>
<li>https : 超文本传输协议的安全方案，默认端口为 443</li>
<li>mailto : 指向邮箱地址</li>
<li>ftp : 文件传输协议，可以在 ftp 服务器上下载或上传文件</li>
<li>rtsp rtspu : rtsp URL 是可以通过实时流传输协议解析的音频/视频的媒体资源标识符</li>
<li>file : 表示一台指定主机上可以直接访问的文件</li>
<li>news : 根据 RFC 1036 的定义，用来访问一些特定的文章和新闻组</li>
<li>telnet : 用于访问交互式业务</li>
</ul>
]]></content>
      
        <categories>
            
            <category> HTTP </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTP 原理]]></title>
      <url>/2017/12/31/HTTP%20%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="TCP-IP-协议参考模型"><a href="#TCP-IP-协议参考模型" class="headerlink" title="TCP/IP 协议参考模型"></a>TCP/IP 协议参考模型</h1><p><img src="/img/TCP-IP参考模型.png" alt="TCP/IP 协议参考模型"></p>
<p>TCP/IP是全世界的计算机和网络设备常用的层次化分组交换网络协议集，属于参考模型的传输层，用于过滤掉每个计算机的差异性，隐藏相关弱点，向应用程序提供“相同的”服务接口。</p>
<h1 id="HTTP-概念"><a href="#HTTP-概念" class="headerlink" title="HTTP 概念"></a>HTTP 概念</h1><p>http 是数据传输协议（超文本传输协议），用来沟通客户端和服务器，是一种 client-server 协议，它是承载于 TCP/IP 之上。通常是由像浏览器这样的接受方发起的，像浏览器这样的客户端发出的消息叫做 requests，那么被服务端回应的消息就叫做 responses。</p>
<h2 id="媒体资源"><a href="#媒体资源" class="headerlink" title="媒体资源"></a>媒体资源</h2><p>网络上的一切内容皆资源，无论是静态文件，还是动态生成的代码。</p>
<p>我们通过 <strong><em>媒体类型(数据类型标记)</em></strong> 来告诉接收端(一般指客户端)，接收到的数据是什么类型，让接收端知道怎么才能处理该文件。</p>
<p>常见标记方式就是 <strong><em>MIME</em></strong> ，MIME描述了文件的主要类型以及特定子类型，例如：”Content-Type”:”text/html”，其中text描述的文件的主要类型是文本，而其特定类型是html文档！</p>
<h2 id="URI、URL、URN"><a href="#URI、URL、URN" class="headerlink" title="URI、URL、URN"></a>URI、URL、URN</h2><p>URI(Uniform Resource Identifier) 统一资源标识符，它的作用就是在网络上唯一确定一个资源。它有两个子集：URL(Uniform Resource Location)和URN(Uniform Resource Name)。如果不特别声明，我们所说的URI就是指URL。URL 通过给出的地址指向网络资源，URN 通过给出的命名指向资源（就像 ISBN 对于一本书一样）。</p>
<h2 id="HTTP-事务"><a href="#HTTP-事务" class="headerlink" title="HTTP 事务"></a>HTTP 事务</h2><p>“一次http链接（不包括tcp/ip连接，只包括一次http消息发送与接收）”的整个过程，由请求命令和响应结果组成</p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>消息是http协议一种纯文本的数据格式，分为请求消息和响应消息，两种消息都具有类似的结构，分别由三个部分构成：起始行、首部、主体，起始行描述消息干了什么！首部描述消息传输的具体细节！主体描述传输的实际内容！</p>
<h2 id="HTTP-的组件系统"><a href="#HTTP-的组件系统" class="headerlink" title="HTTP 的组件系统"></a>HTTP 的组件系统</h2><p>代理、缓存、网关、隧道及Agent代理</p>
<ul>
<li>代理代理位于客户端和服务器之间，接收所有客户端的HTTP请求，并把这些请求转发给服务器（可能会对请求进行修改之后转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。代理的主要作用有过滤、屏蔽等！（还有需要注意一点：代理既可以代表服务器对客户端进行响应，又可以代表客户端对服务器进行请求！）</li>
<li>缓存：首先说明一下，缓存某种意义上来说也是一种代理服务器。它主要使用代表服务器对客户端进行响应。发送预先缓存好的资源的副本。这样会加快事务响应速度、同时也会减少服务器的负载、减轻带宽等问题！</li>
<li>网关：网关是一种特殊的服务器，面对客户端时好像它就是服务器，而对于服务器，他又充当客户端的角色，它的主要作用是协议转换！例如HTTP/FTP网关。</li>
<li>隧道：就是一个连接通道，用于在http信道上发送非http协议的资源。</li>
<li>Agent代理：就是我们平时所说的浏览器，以及web机器人、爬虫等！</li>
</ul>
]]></content>
      
        <categories>
            
            <category> HTTP </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器的标准模式和怪异模式]]></title>
      <url>/2017/12/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%80%AA%E5%BC%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="浏览器的标准模式和怪异模式"><a href="#浏览器的标准模式和怪异模式" class="headerlink" title="浏览器的标准模式和怪异模式"></a>浏览器的标准模式和怪异模式</h1><h2 id="不同模式由来-来源"><a href="#不同模式由来-来源" class="headerlink" title="不同模式由来 来源"></a>不同模式由来 <a href="https://www.jianshu.com/p/dcab7cde8c04" target="_blank" rel="noopener">来源</a></h2><p>在HTML与CSS的标准化未完成之前，各个浏览器对于HTML和CSS的解析有各自不同的实现，而有很多旧的网页都是按照这些非标准的实现去设计的。在HTML与CSS标准确定之后，浏览器一方面要按照标准去实现对HTML与CSS的支持，另一方面又要保证对非标准的旧网页设计的后向兼容性。因此，现代的浏览器一般都有两种渲染模式：标准模式和怪异模式。在标准模式下，浏览器按照HTML与CSS标准对文档进行解析和渲染；而在怪异模式下，浏览器则按照旧有的非标准的实现方式对文档进行解析和渲染。这样的话，对于旧有的网页，浏览器启动怪异模式，就能够使得旧网页正常显示；对于新的网页，则可以启动标准模式，使得新网页能够使用HTML与CSS的标准特性。</p>
<h2 id="浏览器如何确定使用哪种渲染模式"><a href="#浏览器如何确定使用哪种渲染模式" class="headerlink" title="浏览器如何确定使用哪种渲染模式"></a>浏览器如何确定使用哪种渲染模式</h2><p>当浏览器遇到正确的文档声明时，浏览器就会启动标准模式，按照制定的文档类型标准解析和渲染文档。而对于旧有的网页，由于网页编写的当时标准还没有确定，所以一般是不会有文档类型声明的。所以，对于没有文档类型声明或者文档类型声明不正确的文档，浏览器就会认为它是一个旧的HTML文档，就会使用怪异模式解析和渲染该文档。</p>
<p>HTML5 DOCTYPE 声明： \&lt;!DOCTYPE html></p>
<p>注：由于已经进入 HTML5 很久了，HTML5 之前的文档类型声明就不写了，估计现在没有谁还去用。</p>
<h2 id="标准模式与怪异模式常见区别"><a href="#标准模式与怪异模式常见区别" class="headerlink" title="标准模式与怪异模式常见区别"></a>标准模式与怪异模式常见区别</h2><ol>
<li>盒模型的处理差异 (已经验证)</li>
</ol>
<ul>
<li>IE盒子模型：</li>
</ul>
<p><img src="/img/iebox.png" alt="IE 盒子模型"></p>
<ul>
<li>标准盒子模型：</li>
</ul>
<p><img src="/img/box.png" alt="标准盒子模型"></p>
<p>ps:当然盒子模型可以通过 css 属性 <code>box-sizing</code> 来切换。</p>
<ol>
<li>行内元素的垂直对齐 (已经验证)</li>
</ol>
<p>对于 inline 元素和 table-cell 元素，标准模式下 vertical-align 属性默认取值为 baseline .在怪异模式下， table 单元格中的图片的 vertical-align 属性默认取值为 bottom ，因此在图片底部会有及像素的空间。</p>
<ol>
<li>\<table> 元素中的字体 (已经验证)</table></li>
</ol>
<p>CSS 中，对于 font 的属性都是可以继承的，怪异模式下，对于 table 元素，字体的某些元素将不会从 body 等其他封装元素中继承得到，特别是 font-size 属性。</p>
<ol>
<li>内联元素的尺寸 (chrome 未验证成功)</li>
</ol>
<p>标准模式下， non-replaced inline 元素无法自定义大小，怪异模式下，定义这些元素的 width ， height 属性可以影响这些元素显示的尺寸。</p>
<ol>
<li>元素的百分比高度 (chrome 未验证成功)</li>
</ol>
<ul>
<li><p>CSS 中对于元素的百分比高度规定如下：百分比为元素包含块的高度，不可为负值，如果包含块的高度没有显示给出，该值等同于 auto，所以百分比的高度必须在父元素有高度声明的情况下使用。</p>
</li>
<li><p>当一个元素使用百分比高度时，标准模式下，高度取决于内容变化，怪异模式下，百分比高度被正确应用。</p>
</li>
</ul>
<ol>
<li>元素溢出的处理 (chrome 未验证成功)</li>
</ol>
<p>标准模式下，overflow 取默认值visible ，在怪异模式下，该溢出会被当做扩展 box 来对待，即元素的大小由其内容决定，溢出不会裁减，元素框自动调整，包含溢出内容。</p>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML5 新特性]]></title>
      <url>/2017/12/28/HTML5%20%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<h1 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 新特性"></a>HTML5 新特性</h1><h2 id="HTML5-新特性-一-语义标签"><a href="#HTML5-新特性-一-语义标签" class="headerlink" title="HTML5 新特性(一)语义标签"></a>HTML5 新特性(一)语义标签</h2><ol>
<li><p>section 定义文档中的主体部分的节、段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;section&gt;&lt;/section&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>article 定义来自外部的一个独立的、完整的内容块</p>
</li>
</ol>
<p>一个特殊的section标签，比section有更明确的语义。定义来自外部的一个独立的、完整的内容块，例如什么论坛的文章，博客的文本。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;article&gt;&lt;/article&gt;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>aside 用来装载页面中非正文的内容，独立于其他模块，广告、成组的链接、侧边栏。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aside&gt;&lt;/aside&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>header 和 footer </p>
</li>
</ol>
<ul>
<li>header 定义文档、页面的页眉。通常是一些引导和导航信息，不局限于整个页面头部，也可以用在内容里。</li>
<li>footer 定义了文档、页面的页脚，和 header 类似。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;&lt;/header&gt;</span><br><span class="line">&lt;footer&gt;&lt;/footer&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>nav 定义了一个链接组组成的导航部分</li>
</ol>
<p>其中的链接可以链接到其他网页或者当前页面的其他部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav&gt;&lt;/nav&gt;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>figure 和 figcaption</li>
</ol>
<ul>
<li>figure 用于对元素进行组合</li>
<li>figcaption 为figure元素加标题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;figure&gt;</span><br><span class="line">  &lt;img src=&quot;img/mdn-logo-sm.png&quot; alt=&quot;An awesome picture&quot;&gt;	</span><br><span class="line">  &lt;figcaption&gt;Fig1. MDN Logo&lt;/figcaption&gt;</span><br><span class="line">&lt;/figure&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>details 和 summary</li>
</ol>
<ul>
<li>details 定义元素的细节,用户可以点击查看或者隐藏</li>
<li>summary 用作 一个 details 元素的一个内容的摘要，标题或图例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;Some details&lt;/summary&gt; </span><br><span class="line">  &lt;p&gt;More info about the details.&lt;/p&gt; </span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>canvas 用来进行canvas绘图。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>video 和 audio</li>
</ol>
<ul>
<li>video 定义视频</li>
<li>audio 定义音频</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;video&gt;&lt;/video&gt;</span><br><span class="line">&lt;audio&gt;&lt;/audio&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>source 和 track</li>
</ol>
<ul>
<li>source 该标签为媒介元素(比如video、audio)定义媒介元素</li>
<li>track 媒体类元素的外部轨道</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;video controls&gt;</span><br><span class="line">  &lt;source src=&quot;foo.webm&quot; type=&quot;video/webm&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;foo.ogg&quot; type=&quot;video/ogg&quot;&gt; </span><br><span class="line">  &lt;source src=&quot;foo.mov&quot; type=&quot;video/quicktime&quot;&gt;</span><br><span class="line">  &lt;track kind=&quot;captions&quot; src=&quot;foo.en.vtt&quot; srclang=&quot;en&quot; label=&quot;English&quot;&gt;</span><br><span class="line">  &lt;track kind=&quot;captions&quot; src=&quot;foo.sv.vtt&quot; srclang=&quot;sv&quot; label=&quot;Svenska&quot;&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>datalist 包含了一组 option 元素,这些元素表示其它表单控件可选值.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;label&gt;Choose a browser from this list:</span><br><span class="line">&lt;input list=&quot;browsers&quot; name=&quot;myBrowser&quot; /&gt;&lt;/label&gt;</span><br><span class="line">&lt;datalist id=&quot;browsers&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;Chrome&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;Firefox&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;Internet Explorer&quot;&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>mark 代表突出显示的文字</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&amp;lt;mark&amp;gt; 元素用于 &lt;mark&gt;高亮&lt;/mark&gt; 文本&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>output 表示计算或用户操作的结果。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form oninput=&quot;result.value=parseInt(a.value)+parseInt(b.value)&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;range&quot; name=&quot;b&quot; value=&quot;50&quot; /&gt; +</span><br><span class="line">    &lt;input type=&quot;number&quot; name=&quot;a&quot; value=&quot;10&quot; /&gt; =</span><br><span class="line">    &lt;output name=&quot;result&quot;&gt;&lt;/output&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>progress 进度条，运行中的进度</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;progress value=&quot;70&quot; max=&quot;100&quot;&gt;70 %&lt;/progress&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>time 表示日期则也可包含时间和时区</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;The concert starts at &lt;time&gt;20:00&lt;/time&gt;.&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h2 id="新特性-二-表单新特性"><a href="#新特性-二-表单新特性" class="headerlink" title="新特性(二)表单新特性"></a>新特性(二)表单新特性</h2><ol>
<li>10个 input 的 type 值</li>
</ol>
<ul>
<li>email: 邮件输入域，在表单提交时提供简单的邮箱格式验证，并弹出一个提示窗口。</li>
<li>url: 地址输入域，在表单提交时提供简单的URL地址格式验证，并弹出一个提示窗口。</li>
<li>number: 数字输入域。(可设置min、max、step)</li>
<li>tel: 电话号码输入域，在手机浏览器中弹出数字输入域。</li>
<li>search: 搜索输入域，在手机浏览器右下角呈现搜索按键。</li>
<li>range: 范围选择控件。</li>
<li>color: 颜色选择控件。</li>
<li>date/month/week: 时间选择控件。</li>
</ul>
<ol>
<li>11个表单元素新属性</li>
</ol>
<ul>
<li>autocomplete: 自动补全，是否自动记录之前提交的数据，以用于下一次输入建议。</li>
<li>placeholder: 占位符，用于在输入框中显示提示性文字，与value不同，不能被提交。</li>
<li>autofocus: 自动获得输入焦点。</li>
<li>multiple: 是否允许多个输入值，若声明该属性，那么输入框中允许输入多个用逗号隔开的值。</li>
<li>form: 值为某个表单的id，若设置，则该输入域可放在该表单外面。</li>
<li>required: 在表单提交时会验证是否有输入，没有则弹出提示消息。</li>
<li>maxlength: 限制最大长度，只有在有输入的情况下才有用，不区分中英文。</li>
<li>minlength: 限制最小长度，但它不是H5标准属性，仅部分浏览器支持。</li>
<li>min: 限定输入数字的最小值。</li>
<li>max: 限定输入数字的最大值。</li>
<li>step: 限定输入数字的步长，与min连用。</li>
<li>pattern: 指定一个正则表达式，对输入进行验证。(正则默认首尾加^$)</li>
</ul>
<h2 id="新特性-三-Video-和-audio"><a href="#新特性-三-Video-和-audio" class="headerlink" title="新特性(三) Video 和 audio"></a>新特性(三) Video 和 audio</h2><ul>
<li>视频(video) H5新加了video标签，用来播放视频，默认为一个300*150的inline-block。</li>
<li>音频(audio) H5新加了audio标签，用来播放音频，默认为一个300*30并且display为none的inline-block(除非有controls属性)。但手机ios系统中的safari浏览器不支持这个标签，其余的都支持。</li>
</ul>
<p>属性: </p>
<ul>
<li>src: 指定要播放的资源路径。</li>
<li>autoplay: 是否自动播放。</li>
<li>controls: 是否显示播放控件。</li>
<li>currentTime: 当前播放的时间点。</li>
<li>duration: 总时长(s)。</li>
<li>ended: 是否结束。</li>
<li>loop: 是否循环播放。</li>
<li>muted: 是否静音。</li>
<li>volume: 音量设置(0~1)。</li>
<li>paused: 是否在播放。</li>
<li>preload: 指定视频预加载方案。</li>
<li>play(): 播放。</li>
<li>pause(): 暂停。</li>
<li>onplay: 开始播放事件。</li>
<li>onpause: 开始暂停事件。</li>
<li>onplaying: 正在播放中事件。</li>
</ul>
<h2 id="新特性-四-canvas"><a href="#新特性-四-canvas" class="headerlink" title="新特性(四) canvas"></a>新特性(四) canvas</h2><p>H5引入了canvas标签，默认是一个300*150的inline-block。</p>
<p>canvas的宽高只能用它自身的width和height属性来指定，而不能使用css样式中的width、height。</p>
<ol>
<li><p>获得‘画笔’对象，canvas所有的任务都需要它来执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ctx=canvas.getContext(&apos;2d&apos;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些canvas常用的属性</p>
</li>
</ol>
<ul>
<li>fillStyle: 填充样式</li>
<li>strokeStyle: 描边样式</li>
<li>lineWidth: 描边宽度</li>
<li>font: 绘制文本所用的字体大小和类型</li>
<li>textBaseline: 文本对其的基线</li>
<li>shadowOffsetX、shadowOffsetY: 阴影偏移量</li>
</ul>
<ol>
<li>使用canvas绘制图形</li>
</ol>
<ul>
<li><p>绘制矩形</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillRect(x,y,w,h);//填充一个矩形</span><br><span class="line">ctx.strokeRect(x,y,w,h);//描边一个矩形</span><br><span class="line">ctx.clearRect(x,y,w,h);//清除一个矩形范围内的内容</span><br></pre></td></tr></table></figure>
</li>
<li><p>绘制文本</p>
</li>
</ul>
<p>*要注意的是文本的定位点默认在文本基线(alphabetic)的起始点！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillText(txt,x,y);//填充文本</span><br><span class="line">ctx.strokeText(txt,x,y);//描边文本</span><br><span class="line">ctx.measureText(txt);//测量</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>为图形文字添加阴影</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctx.shadowColor=&apos;#000&apos;;//颜色</span><br><span class="line">ctx.shadowOffsetX=8;//水平偏移量</span><br><span class="line">ctx.shadowOffsetY=8;//垂直偏移量</span><br><span class="line">ctx.shadowBlur=10;//模糊半径</span><br></pre></td></tr></table></figure>
</li>
<li><p>在绘图时使用渐变色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.createLinearGradient(x1,y1,x2,y2);//创建线性渐变对象</span><br><span class="line">ctx.createRadialGradient(x1,y1,r1,x2,y2,r2);//创建径向渐变对象</span><br><span class="line">ctx.addColorStop;//添加颜色点</span><br></pre></td></tr></table></figure>
</li>
<li><p>绘制路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath();//开始路径</span><br><span class="line">ctx.closePath();//结束路径</span><br><span class="line">ctx.moveTo(x,y);//移动到指定点</span><br><span class="line">ctx.lineTo(x,y);//绘制直线路径到指定点</span><br><span class="line">ctx.arc();//绘制拱形路径</span><br><span class="line">ctx.ellipse();//绘制椭圆路径</span><br><span class="line">ctx.bezierCurveTo();//绘制贝塞尔曲线路径</span><br><span class="line">ctx.linJoin();//修改折线拐点处样式</span><br></pre></td></tr></table></figure>
</li>
<li><p>绘制图像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.drawImage()</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于绘制上下文状态的改变和修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx.translate(x,y);//坐标轴原点移动到指定点</span><br><span class="line">ctx.rotate();//旋转画笔</span><br><span class="line">ctx.scale();//画笔缩放</span><br><span class="line">ctx.save();//保存绘图上下文当前的变形数据</span><br><span class="line">ctx.restore();//恢复最近一次的保存的变形相关的状态</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="新特性-五-SVG"><a href="#新特性-五-SVG" class="headerlink" title="新特性(五) SVG"></a>新特性(五) SVG</h2><p>相对于canvas绘图，SVG是一种绘制矢量图的技术，全称叫做Scalable Vector Graphics，可缩放的矢量图。</p>
<p>在2000年就已经存在，H5把它纳入了标准标签库，并进行了一些瘦身。需要注意的是，SVG图形的属性不属于HTML DOM标准，需要用核心DOM的方法来操作；</p>
<p>SVG的样式可以用css，但是只能用其专有的属性；如果要使用js动态生成SVG其中的元素，创建方法得用document.createElementNS(‘<a href="http://www.w3.org/2000/svg&#39;,&#39;标签名&#39;)；SVG元素的nodeName都是纯小写形式。" target="_blank" rel="noopener">http://www.w3.org/2000/svg&#39;,&#39;标签名&#39;)；SVG元素的nodeName都是纯小写形式。</a></p>
<ol>
<li>使用方法</li>
</ol>
<p>在HTML文件中直接使用SVG相关标签(\<svg>\</svg>)即可，默认是一个300*150的inline-block。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element" target="_blank" rel="noopener">SVG 元素参考手册</a>，<br><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute" target="_blank" rel="noopener">SVG 属性参考手册</a>。</p>
<h2 id="新特性-六-地理位置"><a href="#新特性-六-地理位置" class="headerlink" title="新特性(六) 地理位置"></a>新特性(六) 地理位置</h2><p>简单地用一句话概括就是，使用js获取浏览器当前所在的地理坐标，实现LBS(Location Based Service，基于定位的服务)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//确定设备的位置并返回一个携带位置信息的 Position 对象。</span><br><span class="line">Geolocation.getCurrentPosition() </span><br><span class="line">//注册一个位置改变监听器，每当设备位置改变时，返回一个 long 类型的该监听器的ID值。</span><br><span class="line">Geolocation.watchPosition()</span><br><span class="line">//取消由 watchPosition()注册的位置监听器。</span><br><span class="line">Geolocation.clearWatch()</span><br></pre></td></tr></table></figure></p>
<h2 id="新特性-七-拖放-API"><a href="#新特性-七-拖放-API" class="headerlink" title="新特性(七) 拖放 API"></a>新特性(七) 拖放 API</h2><p>拖放API是H5专门为了鼠标拖放而新提供了7个事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drag dragend dragenter dragleave dragover dragstart drop</span><br></pre></td></tr></table></figure></p>
<h2 id="新特性-八-Web-Worker"><a href="#新特性-八-Web-Worker" class="headerlink" title="新特性(八) Web Worker"></a>新特性(八) Web Worker</h2><p>由于js是单线程的，所以H5添加了这个叫做webWorker的概念，允许js创建多个线程，但是子线程完全受主线程控制，且不能操作DOM，从而来处理一些比较耗时的操作。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">Web Worker 教程</a></p>
<h2 id="新特性-九-Web-Storage"><a href="#新特性-九-Web-Storage" class="headerlink" title="新特性(九) Web Storage"></a>新特性(九) Web Storage</h2><p>H5的webStorage技术一共提供了两个对象：window.sessionStorage和window.localStorage。</p>
<ol>
<li>window.sessionStorage 会话级存储</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//存储一个数据</span><br><span class="line">sessionStorage[&apos;key&apos;]=value;</span><br><span class="line">sessionStorage.setItem(&apos;key&apos;,value);</span><br><span class="line">//读取一个数据</span><br><span class="line">var data = sessionStorage[&apos;key&apos;];</span><br><span class="line">var data = sessionStorage.getItem(&apos;key&apos;);</span><br><span class="line">//获取数据的个数</span><br><span class="line">sessionStorage.length</span><br><span class="line">//清除所有的数据</span><br><span class="line">sessionStorage.clear();</span><br><span class="line">//清除一个数据</span><br><span class="line">sessionStorage.removeItem(&apos;key&apos;);</span><br></pre></td></tr></table></figure>
<ol>
<li>window.localStorage 本地存储<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//存储一个数据</span><br><span class="line">localStorage[&apos;key&apos;]=value;</span><br><span class="line">localStorage.setItem(&apos;key&apos;,value);</span><br><span class="line">//读取一个数据</span><br><span class="line">var data = localStorage[&apos;key&apos;];</span><br><span class="line">var data = localStorage.getItem(&apos;key&apos;);</span><br><span class="line">//获取数据的个数</span><br><span class="line">localStorage.length</span><br><span class="line">//清除所有的数据</span><br><span class="line">localStorage.clear();</span><br><span class="line">//清除一个数据</span><br><span class="line">localStorage.removeItem(&apos;key&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API" target="_blank" rel="noopener">Web Storage 教程</a></p>
<p>　　</p>
<h2 id="新特性-十-Web-Socket"><a href="#新特性-十-Web-Socket" class="headerlink" title="新特性(十) Web Socket"></a>新特性(十) Web Socket</h2><p>webSocket是H5新加的一个协议，为了解决http协议的request、response一一对应和它自身的被动性，以及ajax轮询等问题。一方可以发送多条信息，连接不中断，永久连接，但也导致了服务器连接的客户端数量有限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WebSocket(&apos;ws://地址:端口号&apos;);    //创建ws客户端</span><br><span class="line">ws.onopen=function()&#123;                        //连接成功时触发</span><br><span class="line">　　ws.send();                                //发送信息</span><br><span class="line">　　ws.onmessage=function(e)&#123;                 //获得信息时触发</span><br><span class="line">      e.data;                                //接收的信息</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noopener">Web Socket 教程</a></p>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack 学习笔记二]]></title>
      <url>/2017/08/22/webpack%20note%2002/</url>
      <content type="html"><![CDATA[<h2 id="loader-概念引入"><a href="#loader-概念引入" class="headerlink" title="loader 概念引入"></a>loader 概念引入</h2><p>webpack 第一理念为：一切皆模板 ，然而 webpack 只能处理 javascript 模块，那它是如何处理 “一切皆模块” 的呢？</p>
<p>这儿就需要引入 loader 的概念，webpack 通过对应的 loader 处理对应的模块，举个简单例子，我们可以通过 css-loader|style-loader 处理 CSS 文件，通过 file-loader|url-loader 处理图片或者文件。</p>
<p>以下是概念（复制的，咳咳~~~）</p>
<p>Loader可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过require来加载任何类型的模块或文件，比如VUE、JSX、SASS 或图片。</p>
<p>先来看看 loader 有哪些特性？(网上复制的，咳咳咳咳~~~~。<a href="http://blog.guowenfh.com/2016/03/24/vue-webpack-02-deploy/" target="_blank" rel="noopener">地址</a>)</p>
<ul>
<li>Loader可以通过管道方式链式调用，每个loader可以把资源转换成任意格式并传递给下一个loader，但是最后一个loader必须返回JavaScript。</li>
<li>Loader可以同步或异步执行。</li>
<li>Loader运行在node.js环境中，所以可以做任何可能的事情。</li>
<li>Loader可以接受参数，以此来传递配置项给loader。</li>
<li>Loader可以通过文件扩展名（或正则表达式）绑定给不同类型的文件。</li>
<li>Loader可以通过npm发布和安装。</li>
<li>除了通过package.json的main指定，通常的模块也可以导出一个loader来使用。</li>
<li>Loader可以访问配置。</li>
<li>插件可以让loader拥有更多特性。</li>
<li>Loader可以分发出附加的任意文件。</li>
</ul>
<h2 id="css-loader-style-loader"><a href="#css-loader-style-loader" class="headerlink" title="css-loader|style-loader"></a>css-loader|style-loader</h2><p>进入项目目录安装 css-loader|style-loader </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-loader style-loader --save-dev</span><br></pre></td></tr></table></figure>
<p>安装成功后</p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack 学习笔记一]]></title>
      <url>/2017/08/21/webpack%20note%2001/</url>
      <content type="html"><![CDATA[<p>以下笔记摘抄至 <a href="http://blog.guowenfh.com/2016/03/24/vue-webpack-01-base/" target="_blank" rel="noopener">webpack入坑之旅</a> ，再加上自己的一部分理解。</p>
<h2 id="webpack-理念"><a href="#webpack-理念" class="headerlink" title="webpack 理念"></a>webpack 理念</h2><p>这有必要再次阐述一下 webpack 的理念：</p>
<ol>
<li>一切皆模块<br>正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。因此，你可以require(‘myJSfile.js’)亦可以require(‘myCSSfile.css’)。这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。</li>
<li>按需加载<br>传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的bundle.js文件。但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。</li>
</ol>
<h2 id="Webapck-和其他模块化工具有什么区别呢？"><a href="#Webapck-和其他模块化工具有什么区别呢？" class="headerlink" title="Webapck 和其他模块化工具有什么区别呢？"></a>Webapck 和其他模块化工具有什么区别呢？</h2><p>(这部分是复制的)</p>
<ol>
<li>代码拆分<br>Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的快。在优化了依赖树后，每一个异步区块都作为一个文件被打包。</li>
<li>Loader<br>Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。</li>
<li>智能解析<br>Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 require(“./templates/“ + name + “.jade”)。</li>
<li>插件系统<br>Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。</li>
<li>快速运行<br>Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。</li>
</ol>
<h2 id="webpack-安装"><a href="#webpack-安装" class="headerlink" title="webpack 安装"></a>webpack 安装</h2><p>本笔记介绍使用 npm 安装 webpack ，和其他 npm 包安装一样使用安装指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//进入文件目录</span><br><span class="line">cd &lt;filedir&gt;</span><br><span class="line">// 初始化 package.json，如无需要直接一直 enter 即可</span><br><span class="line">npm init</span><br><span class="line">// 安装 webpack 可以使用简化命令 npm i webpack -D</span><br><span class="line">npm install webpack --save-dev</span><br><span class="line">// --save ：模块名将被添加到dependencies，可以简化为参数-S。</span><br><span class="line">// --save-dev  –save-dev: 模块名将被添加到devDependencies，可以简化为参数-D。</span><br></pre></td></tr></table></figure></p>
<p>之后得到的 package.json 是类似这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;app3&quot;,//项目名称</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,//项目版本号</span><br><span class="line">  &quot;description&quot;: &quot;webpack learn&quot;,//项目描述</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,//项目主入口</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;//npm命令</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;morelearn&quot;,//作者</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,//许可证</span><br><span class="line">  &quot;devDependencies&quot;: &#123; //依赖包</span><br><span class="line">    &quot;webpack&quot;: &quot;^2.4.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="webpack-最最简单例子-将简单复杂化"><a href="#webpack-最最简单例子-将简单复杂化" class="headerlink" title="webpack 最最简单例子(将简单复杂化 - _ -|||)"></a>webpack 最最简单例子(将简单复杂化 - _ -|||)</h2><p>接下来进行最最简单的项目吧：</p>
<ol>
<li>创建一个静态文件 index.html ;</li>
<li>创建 webpack 主入口 entry.js ;</li>
</ol>
<p>分别代码如下：<br>index.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">  &lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;webpack learn&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1 id=&quot;h1&quot;&gt;&lt;/h1&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;!-- 生成的js文件为 bundle.js 所以这儿引入这个文件 --&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>entry.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** entry.js 入口 **/</span><br><span class="line">document.getElementById(&quot;h1&quot;).innerHTML=&quot;这是 webpack 打包成功！&quot;;</span><br></pre></td></tr></table></figure></p>
<p>运行命令 <code>webpack entry.js bundle.js</code><br>成功CMD命令行显示如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hash: 5684794b124eeb70194d</span><br><span class="line">Version: webpack 2.4.1</span><br><span class="line">Time: 82ms</span><br><span class="line">    Asset     Size  Chunks             Chunk Names</span><br><span class="line">bundle.js  2.71 kB       0  [emitted]  main</span><br><span class="line">   [0] ./entry.js 80 bytes &#123;0&#125; [built]</span><br></pre></td></tr></table></figure></p>
<p>可以看一下 bundle.js 代码，发现在之前得一段代码是 webpack 的封装代码，具体功能暂时没有详细看，所以没能说明一个仔细的来。在之后的一段代码为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function(module, exports, __webpack_require__) &#123;</span><br><span class="line">  /** entry.js 入口 **/</span><br><span class="line">  document.getElementById(&quot;h1&quot;).innerHTML=&quot;这是 webpack 打包成功！&quot;;</span><br><span class="line">  __webpack_require__(0);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>由此可见，webpack 将 entry.js 的代码使用匿名函数的方式打包到了 bundle.js 里面。</p>
<p>这儿会产生一个想法，干嘛用它呀，反而更加复杂了（雅蠛蝶）。</p>
<h2 id="一个更好的例子-有点理解了"><a href="#一个更好的例子-有点理解了" class="headerlink" title="一个更好的例子(有点理解了)"></a>一个更好的例子(有点理解了)</h2><p>在上面的基础上再来新创建一个 first.js ，在 entry.js 里面引入它</p>
<p>first.js 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var h2 = document.createElement(&quot;h2&quot;);</span><br><span class="line">h2.innerHTML = &quot;这是入口引入的另外一个js，打包成功~~&quot;</span><br><span class="line">document.body.appendChild(h2);</span><br></pre></td></tr></table></figure></p>
<p>entry.js 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/** entry.js 入口 **/</span><br><span class="line">document.getElementById(&quot;h1&quot;).innerHTML=&quot;这是 webpack 打包成功！&quot;;</span><br><span class="line">require(&quot;./first.js&quot;);</span><br></pre></td></tr></table></figure></p>
<p>再运行命令 <code>webpack entry.js bundle.js</code><br>成功CMD命令行显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hash: f925000a88e899c2ac1c</span><br><span class="line">Version: webpack 2.4.1</span><br><span class="line">Time: 146ms</span><br><span class="line">    Asset     Size  Chunks             Chu</span><br><span class="line">bundle.js  2.94 kB       0  [emitted]  mai</span><br><span class="line">   [0] ./first.js 117 bytes &#123;0&#125; [built]</span><br><span class="line">   [1] ./entry.js 106 bytes &#123;0&#125; [built]</span><br></pre></td></tr></table></figure></p>
<p>同样在 bundle.js 里面在 entry.js 代码的上方增加了代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function(module, exports) &#123;</span><br><span class="line">  var h2 = document.createElement(&quot;h2&quot;);</span><br><span class="line">  h2.innerHTML = &quot;这是入口引入的另外一个js，打包成功~~&quot;</span><br><span class="line">  document.body.appendChild(h2);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>于是我们猜测 webpack 是通过在入口文件里面递归寻找依赖文件，为了证实我们的猜想，我们在 first.js 里面增加一个依赖，来看看情况，创建 second.js 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var h3 = document.createElement(&quot;h3&quot;);</span><br><span class="line">h3.innerHTML = &quot;验证递归寻找依赖并打包的猜想&quot;;</span><br><span class="line">document.body.appendChild(h3);</span><br></pre></td></tr></table></figure></p>
<p>在 first.js 里面增加一行代码 <code>require(&quot;./second.js&quot;);</code><br>再次运行命令 <code>webpack entry.js bundle.js</code><br>运行成功CMD命令行显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hash: 6091c80a79e5d89e3c28</span><br><span class="line">Version: webpack 2.4.1</span><br><span class="line">Time: 325ms</span><br><span class="line">    Asset     Size  Chunks             Chun</span><br><span class="line">bundle.js  3.14 kB       0  [emitted]  main</span><br><span class="line">   [0] ./first.js 138 bytes &#123;0&#125; [built]</span><br><span class="line">   [1] ./entry.js 106 bytes &#123;0&#125; [built]</span><br><span class="line">   [2] ./second.js 110 bytes &#123;0&#125; [built]</span><br></pre></td></tr></table></figure></p>
<p>同样在 bundle.js 里面增加了代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function(module, exports) &#123;</span><br><span class="line">var h3 = document.createElement(&quot;h3&quot;);</span><br><span class="line">h3.innerHTML = &quot;验证递归寻找依赖并打包的猜想&quot;;</span><br><span class="line">document.body.appendChild(h3);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在我们来看整个 bundle.js 里面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/******/ ([</span><br><span class="line">/* 0 */</span><br><span class="line">/***/ (function(module, exports, __webpack_require__) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var h2 = document.createElement(&quot;h2&quot;);</span><br><span class="line">h2.innerHTML = &quot;这是入口引入的另外一个js，打包成功~~&quot;</span><br><span class="line">document.body.appendChild(h2);</span><br><span class="line"></span><br><span class="line">__webpack_require__(2);</span><br><span class="line"></span><br><span class="line">/***/ &#125;),</span><br><span class="line">/* 1 */</span><br><span class="line">/***/ (function(module, exports, __webpack_require__) &#123;</span><br><span class="line"></span><br><span class="line">/** entry.js 入口 **/</span><br><span class="line">document.getElementById(&quot;h1&quot;).innerHTML=&quot;这是 webpack 打包成功！&quot;;</span><br><span class="line"></span><br><span class="line">__webpack_require__(0);</span><br><span class="line"></span><br><span class="line">/***/ &#125;),</span><br><span class="line">/* 2 */</span><br><span class="line">/***/ (function(module, exports) &#123;</span><br><span class="line"></span><br><span class="line">var h3 = document.createElement(&quot;h3&quot;);</span><br><span class="line">h3.innerHTML = &quot;验证递归寻找依赖并打包的猜想&quot;;</span><br><span class="line">document.body.appendChild(h3);</span><br><span class="line"></span><br><span class="line">/***/ &#125;)</span><br><span class="line">/******/ ]);</span><br></pre></td></tr></table></figure></p>
<p>我们写的三段代码均在这里面，但是这个顺序有点琢磨不透，待下回仔细分析。</p>
<p>通过以上两个例子，我们能够简单的理解 webpack 的理念和方法。那么接下来我们进入到更加深入的使用 webpack 来加强理解。</p>
]]></content>
      
        <categories>
            
            <category> Tool </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[常用 META 整理]]></title>
      <url>/2017/08/20/html-meta/</url>
      <content type="html"><![CDATA[<p>常用 meta 整理</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><table>
<thead>
<tr>
<th></th>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>content</td>
<td>some text</td>
<td>定义与http-equiv或name属性相关的元信息</td>
<td></td>
</tr>
<tr>
<td>http-equiv</td>
<td>content-type / expire / refresh / set-cookie</td>
<td>把content属性关联到HTTP头部。</td>
</tr>
<tr>
<td>name</td>
<td>author / description / keywords / generator / revised / others</td>
<td>把 content 属性关联到一个名称。</td>
</tr>
<tr>
<td>content</td>
<td>some text</td>
<td>定义用于翻译 content 属性值的格式。</td>
</tr>
</tbody>
</table>
<h1 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 关键词 描述 作者 --&gt;</span><br><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;your web keywords&quot; /&gt;</span><br><span class="line">&lt;meta name=&quot;description&quot; content=&quot;above 150 words&quot; /&gt;</span><br><span class="line">&lt;meta name=&quot;author&quot; content=&quot;author name&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    all：文件将被检索，且页面上的链接可以被查询；</span><br><span class="line">    none：文件将不被检索，且页面上的链接不可以被查询；</span><br><span class="line">    index：文件将被检索；</span><br><span class="line">    follow：页面上的链接可以被查询；</span><br><span class="line">    noindex：文件将不被检索；</span><br><span class="line">    nofollow：页面上的链接不可以被查询。</span><br><span class="line"> --&gt;</span><br><span class="line"></span><br><span class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=&quot; /&gt;</span><br><span class="line">&lt;!-- content内的数字代表时间（秒），既多少时间后刷新。如果加url,则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。 --&gt;</span><br><span class="line">&lt;meta name=&quot;google&quot; content=&quot;index,follow&quot; /&gt;</span><br><span class="line">&lt;meta name=&quot;googlebot&quot; content=&quot;index,follow&quot; /&gt;</span><br><span class="line">&lt;meta name=&quot;verify&quot; content=&quot;index,follow&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h1 id="移动设备"><a href="#移动设备" class="headerlink" title="移动设备"></a>移动设备</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 响应式 --&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no&quot;/&gt;</span><br><span class="line">&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 </span><br><span class="line">width：宽度（数值 / device-width）（范围从200 到10,000，默认为980 像素）</span><br><span class="line">height：高度（数值 / device-height）（范围从223 到10,000）</span><br><span class="line">initial-scale：初始的缩放比例 （范围从&gt;0 到10）</span><br><span class="line">minimum-scale：允许用户缩放到的最小比例</span><br><span class="line">maximum-scale：允许用户缩放到的最大比例</span><br><span class="line">user-scalable：用户是否可以手动缩 (no,yes)</span><br><span class="line">minimal-ui：可以在页面加载时最小化上下状态栏。（已弃用） </span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Iphone 独有的一些 meta --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 启用 WebApp 全屏模式 --&gt;</span><br><span class="line">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 隐藏状态栏/设置状态栏颜色   只有在开启WebApp全屏模式时才生效。content的值为default | black | black-translucent 。 --&gt;</span><br><span class="line">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加到主屏后的标题 --&gt;</span><br><span class="line">&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 忽略数字自动识别为电话号码 --&gt;</span><br><span class="line">&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 忽略识别邮箱 --&gt;</span><br><span class="line">&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加智能 App 广告条 Smart App Banner --&gt;</span><br><span class="line">&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 其他不常用设备兼容 --&gt;</span><br><span class="line">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</span><br><span class="line">&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;</span><br><span class="line">&lt;!-- 微软的老式浏览器 --&gt;</span><br><span class="line">&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;</span><br><span class="line">&lt;!-- uc强制竖屏 --&gt;</span><br><span class="line">&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;</span><br><span class="line">&lt;!-- QQ强制竖屏 --&gt;</span><br><span class="line">&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;</span><br><span class="line">&lt;!-- UC强制全屏 --&gt;</span><br><span class="line">&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;</span><br><span class="line">&lt;!-- QQ强制全屏 --&gt;</span><br><span class="line">&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;</span><br><span class="line">&lt;!-- UC应用模式 --&gt;</span><br><span class="line">&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;</span><br><span class="line">&lt;!-- QQ应用模式 --&gt;</span><br><span class="line">&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;</span><br><span class="line">&lt;!-- windows phone 点击无高光 --&gt;</span><br><span class="line">&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;</span><br></pre></td></tr></table></figure>
<h1 id="网页相关"><a href="#网页相关" class="headerlink" title="网页相关"></a>网页相关</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 网页编码 --&gt;</span><br><span class="line">&lt;meta charset=&apos;utf-8&apos; /&gt;</span><br><span class="line"></span><br><span class="line">浏览器兼容</span><br><span class="line">&lt;!-- 关于X-UA-Compatible --&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;</span><br><span class="line">&lt;!-- 使用IE6 --&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=6&quot; &gt;</span><br><span class="line">&lt;!-- 使用IE7 --&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot; &gt;</span><br><span class="line">&lt;!-- 使用IE8 --&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=8&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 浏览器内核控制  国内浏览器的兼容配置 --&gt;</span><br><span class="line">&lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt;</span><br><span class="line">&lt;!-- </span><br><span class="line">1. 搜狗高速浏览器、QQ浏览器：IE内核（兼容模式）</span><br><span class="line">2. 360极速浏览器、遨游浏览器：Webkit内核（极速模式） </span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- windows 8 --&gt;</span><br><span class="line">&lt;!-- Windows 8 磁贴颜色 --&gt;</span><br><span class="line">&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#000&quot;/&gt; </span><br><span class="line">&lt;!-- Windows 8 磁贴图标 --&gt;</span><br><span class="line">&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;icon.png&quot;/&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 站点适配 --&gt;</span><br><span class="line">&lt;meta name=&quot;mobile-agent&quot;content=&quot;format=[wml|xhtml|html5]; url=url&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">[wml|xhtml|html5]根据手机页的协议语言，选择其中一种；</span><br><span class="line">url=&quot;url&quot; 后者代表当前PC页所对应的手机页URL，两者必须是一一对应关系。</span><br><span class="line"> --&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 转码申明：用百度打开网页可能会对其进行转码（比如贴广告），避免转码可添加如下meta --&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h1 id="常用组合"><a href="#常用组合" class="headerlink" title="常用组合"></a>常用组合</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset=&apos;utf-8&apos; /&gt;</span><br><span class="line">&lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no&quot;/&gt;</span><br><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;your web keywords&quot; /&gt;</span><br><span class="line">&lt;meta name=&quot;description&quot; content=&quot;above 150 words&quot; /&gt;</span><br><span class="line">&lt;meta name=&quot;author&quot; content=&quot;author name&quot; /&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
    </entry>
    
  
  
    
  
</search>
